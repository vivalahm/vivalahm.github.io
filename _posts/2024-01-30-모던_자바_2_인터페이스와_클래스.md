---
title: 모던 자바 (2) 인터페이스와 클래스
date: 2024-01-29 14:50:00 +09:00
categories: [JAVA, 모던 자바]
tags:
  [
    JAVA,
    모던 자바
  ]



---

## 도입

- 자바 아키텍트들이 `자바 8`에 새로운 기능, `람다`와 `함수형 프로그래밍`을 적용하기 위해 고민하면서 인터페이스에 변화가 생김
- 인터페이스에 대한 변경은 자바 7버전 부터 시작되었으면 자바 8에서 대대적으로 바뀜
- `인터페이스 변경`이 결국 `함수형 프로그래밍`과 `스트림` 등이 등장할 수 있는 `배경`이 되었고, `컬렉션 프레임워크 개선`의 바탕이 됨

## 인터페이스 사용 시 문제점

- 인터페이스는 단어 그래로 특정 기능에 접근하기 위한 인터페이스 역활

- 주로 여러개의 `구현체`를 `통일화된 명세서`로 정의 하기 위해 사용

- 각 클래스는 원하는 경우에 맞게 실제 구현해야하는 내용을 작성

- 메서드 이름의 통일성도 확보가능

- 인터페이스는 자바 1.0 버전이 나온 이후 오랜 기간 변하지 않음

- 객체 지향 프로그래밍을 추구하면서 인터페이스의 개념은 절대 침범할 수 없는 불가침 영역으로 여겨졌었음.

- 자바가 계속 발전, 개선 되면서 새로운 기능이 추가되며 인터페이스의 문제가 생김

  - 대표적인 문제점은 `한번 배포된 인터페이스는 수정이 어렵다.`

  ```Java
  public interface CompanyEncryption {
  	//파라미터 값을 표준 알고리즘으로 인코딩
  	public byte[] encrypt(byte[] bytes) throw Exception;
  	
  	//인코딩 된 문자를 표준 알고리즘으로 디코딩
  	public byte[] decrypt(byte[] bytes) throw Exception;
  }
  ```

  - 예시는 어느 회사의 보안팀에서 암호화에 대한 표준을 잡기로 하였고, `표준 인터페이스`만 제공하여 실제 암호화 알고리즘은 `각 프로젝트의 환경에 맞게 구현`하기로 한 모습
  - 보안 부서는 해당 인터페이스를 배포하고 각 개발팀은 해당 `인터페이스 명세`를 확인한 후 이를 구현한 알고리즘을 사용
  - 하지만 보안팀은 `추가로` 주어진 문자가 암호화 알고리즘으로 암호화한 것인지 판단하는 `추가 기능`이 필요해져 `인터페이스를 수정`하기로 한다.

  ```Java
  public interface CompanyEncryption {
  	//파라미터 값을 표준 알고리즘으로 인코딩
  	public byte[] encrypt(byte[] bytes) throw Exception;
  	
  	//인코딩 된 문자를 표준 알고리즘으로 디코딩
  	public byte[] decrypt(byte[] bytes) throw Exception;
    
    //파라미터 값이 암호화 알고리즘으로 인코딩되었는지 확인
    public boolean isEncoded(byte[] bytes) throw Exception;
  }
  ```

  - 해당 인터페이스 배포 후 해당 인터페이스를 구현한 모든 클래스에서 `컴파일 에러`가 발생한다. (인터페이스의 메소드는 모두 구현되어야 함.)
  - 개발팀이나 외부에서 `기존 인터페이스를 구현한 클래스`가 너무 많아서 이를 모두 한번에 `수정하는 것이 불가능함.`(인터페이스 의존적 모든 클래스를 수정해야함.)
  - 클래스를 수정하지 않고 인터페이스를 컴파일 해서 배포한 후 일부 소프트웨어에서 `NoSuchMethod` 컴파일 에러가 발생

  

  ```Java
  public interface EncryptionChecker {
    //파라미터 값이 암호화 알고리즘으로 인코딩되었는지 확인
    public boolean isEncoded(byte[] bytes) throw Exception;
  }
  ```

  - 해당 보안 부서는 어쩔수 없이 또 다른 `EncryptionChecker`라는 별도의 인터페이스를 생성하여 배포하였고 인코딩되어 있는지 여부를 체크하는 로직을 추가하라고 공지함.
  -  `NoSuchMethod` 컴파일 에러는 더이상 발생 하지 않았지만, `추가로 메서드가 필요`해지거나 `기존 메서드에 인수를 추가`해야하는 등의 `변경마다 인터페이스를 새로 추가`해줘야하는 문제가 발생

- 대표적으로 `컬렉션 프레임워크`에 이런 문제 발견할 수 이음.

  - 자바1.0 부터 데이터를 관리하는 자료 구조로 사용
  - 버전이 업데이트 될 때 마다 다양한 환경, 특히 `멀티 스레드환경`에 대응하기 위한 자료 구조가 계속 추가됨.
  - `컬렉션 프레임워크`의 핵심 인터페이스를 수정하지 못하고 계속 유지할 수 밖에 없는 이유가 앞선 예시와 같음

- 자바 1.2에 `Collection 인터페이스`가 추가 되었고 8버전 사이 1.3, 1.4, 5, 6, 7 버전에서는 `Collection 인터페이스`에  메서드를 추가 할수 없없다.

  - 메서드 추가를 하지 않은 이유는 영향이 너무 커서 필요해도 쉽게 추가할 수 없었기 때문

- 뿐만 아니라 외부 다양한 라이브러리들, 프레임워크 등에서 상속 받아 별도의 자료 구조를 만들어서 배포하여 사용하고 있다.

- 그러한 영향이나 컴파일 에러를 줄이기 위해 개발자들은 두가지 경우를 놓고 고민

  - 1. 전체 소스 코드를 재컴파일하면서 컴파일 오류 없는지 검증. 필여하다면 메서드를 추가해서 구현
    2. JDK를 업그레이드하지 않고 이전 버전을 유지하면서 그대로 사용
  - 대부분은 2번을 선택

- 그 결과 자바8 이전 `암호화 알고리즘 유틸리티`의 예시와 마찬가지로 `컬렉션 프레임워크`를 처리할 유틸리티 클래스를 제공

  - 그 이름 `Collections 클래스`이다.
  - 자바 7까지는 `collection 인터페이스`에 `sort기능`이 없어서 `collections 클래스` 를 활용 했다.

- 자바 8부터는 기능이 추가되어 다른 클래스의 도움 없이 정렬 작업이 가능해짐.

- 자바의 가장 핵심이 되는 API에서도 이러한 경우가 상당히 많이 있다.



## 인터페이스의 진화

- 자바 8에서 인터페이스의 기능을 대대적으로 변경, 그 핵심이 `디폴트(default) 메서드`이다.

- 최초의 자바 버전에서는 인터페이스에 다음과 같은 제약이 존재

  - 상수를 선언 할 수 있다. 단 `상수는 반드시 값이 할당` 되어야 한다. 명시적으로 `final`을 선언하지 않더라도 `final`로 인식
  - 메서드는 반드시 `추상메서드`여야 한다. 즉, `구현체가 아니라 메서드 명세만 정의`
  - 인터페이스를 `구현한 클래스`는 인터페이스에서 정의한 메서드를 구현하지 않았다면, 반드시 `추상 클래스`로 선언되어야 한다.
  - 인터페이스에 선언된 상수와 메서드에 `public`을 선언하지 않더라도 `public`으로 인식

  위 네가지 조건은 자바 1.x버전 에서 존재하는 제약 조건 여기에 상속 과정, 구현 과정에 추가적인 규칙들이 존재

  ---------

  추가 작성 중...