---
title: 레디스 캐시 어사이드 전략 및 선착순 구현 로직
date: 2023-12-15 10:58:00 +09:00
categories: [Redis, 선착순 쿠폰, 설계]
tags:
  [
    Redis,
    선착순 쿠폰,
    설계
  ]




---

# 레디스 캐시 어사이드 전략 및 선착순 구현 로직

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.connection.RedisConnectionFailureException;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.concurrent.TimeUnit;

@Service
public class EventCouponService {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    // Redis 연결 재시도 횟수
    private static final int MAX_RETRY = 3;

    // 이벤트 정보 업데이트 및 TTL 설정
    public void updateEventInfo(String eventId, String eventData, LocalDateTime startTime, LocalDateTime endTime) {
        String key = "eventid:" + eventId;
        try {
            redisTemplate.opsForValue().set(key, eventData);

            long ttl = ChronoUnit.SECONDS.between(LocalDateTime.now(), endTime);
            if (ttl > 0) {
                redisTemplate.expire(key, ttl, TimeUnit.SECONDS);
            }
        } catch (RedisConnectionFailureException ex) {
            // Redis 연결 실패 처리 (예: 로그 기록, RDBMS로 대체, 등)
            // ...
        }
    }

    // 새로운 쿠폰 정보 추가 및 업데이트
    public void addOrUpdateCoupon(String couponId, int couponCount, LocalDateTime endTime) {
        String countKey = "couponid:" + couponId + ":count";
        try {
            redisTemplate.opsForValue().set(countKey, String.valueOf(couponCount));

            long ttl = ChronoUnit.SECONDS.between(LocalDateTime.now(), endTime);
            if (ttl > 0) {
                redisTemplate.expire(countKey, ttl, TimeUnit.SECONDS);
            }
        } catch (RedisConnectionFailureException ex) {
            // Redis 연결 실패 처리 (예: 로그 기록, RDBMS로 대체, 등)
            // ...
        }
    }

    // 쿠폰 삭제
    public void deleteCoupon(String couponId) {
        String countKey = "couponid:" + couponId + ":count";
        String membersKey = "couponid:" + couponId + ":members";
        try {
            redisTemplate.delete(countKey);
            redisTemplate.delete(membersKey);
        } catch (RedisConnectionFailureException ex) {
            // Redis 연결 실패 처리 (예: 로그 기록, RDBMS로 대체, 등)
            // ...
        }
    }

    // 쿠폰 발급 로직
    public boolean issueCoupon(String couponId, String memberId) {
        try {
            return tryIssueCouponWithRedis(couponId, memberId);
        } catch (RedisConnectionFailureException ex) {
            return issueCouponWithRDBMS(couponId, memberId);
        }
    }

    // Redis를 이용한 쿠폰 발급 시도
    private boolean tryIssueCouponWithRedis(String couponId, String memberId) throws RedisConnectionFailureException {
        String membersKey = "couponid:" + couponId + ":members";
        String countKey = "couponid:" + couponId + ":count";
        int retryCount = 0;

        while (retryCount < MAX_RETRY) {
            try {
                redisTemplate.opsForSet().add(membersKey, memberId);
                Long currentCount = redisTemplate.opsForSet().size(membersKey);
                int couponCount = Integer.parseInt(redisTemplate.opsForValue().get(countKey));

                if (currentCount > couponCount) {
                    throw new IllegalStateException("Coupon limit exceeded");
                }
                return true;
            } catch (RedisConnectionFailureException ex) {
                retryCount++;
                if (retryCount >= MAX_RETRY) {
                    throw ex;
                }
            }
        }
        return false;
    }

    // RDBMS를 이용한 쿠폰 발급
    private boolean issueCouponWithRDBMS(String couponId, String memberId) {
        // RDBMS 연결 및 쿠폰 발급 로직 구현
        // ...
        return true;
    }
}

```



### 테스트 코드

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import java.time.LocalDateTime;

import static org.mockito.Mockito.*;

@ExtendWith(SpringExtension.class)
@SpringBootTest
public class EventCouponServiceTest {

    @Mock
    private RedisTemplate<String, String> redisTemplate;

    @InjectMocks
    private EventCouponService eventCouponService;

    @Test
    public void testUpdateEventInfo() {
        String eventId = "12345";
        String eventData = "Event Data";
        LocalDateTime startTime = LocalDateTime.now();
        LocalDateTime endTime = LocalDateTime.now().plusDays(1);

        eventCouponService.updateEventInfo(eventId, eventData, startTime, endTime);

        verify(redisTemplate, times(1)).opsForValue().set(eq("eventid:" + eventId), eq(eventData));
        // TTL 설정 검증 필요 시 추가
    }

    @Test
    public void testAddOrUpdateCoupon() {
        String couponId = "54321";
        int couponCount = 100;
        LocalDateTime endTime = LocalDateTime.now().plusDays(1);

        eventCouponService.addOrUpdateCoupon(couponId, couponCount, endTime);

        verify(redisTemplate, times(1)).opsForValue().set(eq("couponid:" + couponId + ":count"), eq(String.valueOf(couponCount)));
        // TTL 설정 검증 필요 시 추가
    }

    @Test
    public void testDeleteCoupon() {
        String couponId = "54321";

        eventCouponService.deleteCoupon(couponId);

        verify(redisTemplate, times(1)).delete(eq("couponid:" + couponId + ":count"));
        verify(redisTemplate, times(1)).delete(eq("couponid:" + couponId + ":members"));
    }

    @Test
    public void testIssueCoupon() {
        String couponId = "54321";
        String memberId = "member001";

        eventCouponService.issueCoupon(couponId, memberId);

        // Redis 및 RDBMS 관련 로직 검증
        // 쿠폰 발급 로직 성공 및 실패 케이스 검증 필요
    }
}

```

테스트 시나리오:

1. **이벤트 정보 업데이트**: 이벤트 정보가 Redis에 올바르게 저장되는지 확인합니다.
2. **쿠폰 추가/업데이트**: 쿠폰 정보가 Redis에 올바르게 저장되는지 확인합니다.
3. **쿠폰 삭제**: 쿠폰 정보가 Redis에서 올바르게 삭제되는지 확인합니다.
4. **쿠폰 발급**: 쿠폰 발급 로직이 올바르게 작동하는지 확인합니다.